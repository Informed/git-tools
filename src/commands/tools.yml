# This code is licensed from CircleCI to the user under the MIT license.
# See here for details: https://circleci.com/developer/orbs/licensing
commands:
  checkout:
    description: Checkout your source from your VCS provider.
    parameters:
      auth:
        default: SSH
        description: Authenticate over your prefered method. (HTTPS, SSH)
        enum:
        - HTTPS
        - SSH
        type: enum
      cache_enabled:
        default: true
        description: Cache your checked out code between Workflow jobs.
        type: boolean
      depth:
        default: 0
        description: Set a clone depth. A value of 0 will not use a shallow clone.
        type: integer
    steps:
    - git-tools-setup
    - run:
        command: |
          # Workaround old docker images with incorrect $HOME
          # check https://github.com/docker/docker/issues/2968 for details
          if [ "${HOME}" = "/" ]
          then
            export HOME=$(getent passwd $(id -un) | cut -d: -f6)
          fi
          # Add known hosts
          mkdir -p ~/.ssh
          echo 'github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==' \>> ~/.ssh/known_hosts
          echo 'bitbucket.org ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAubiN81eDcafrgMeLzaFPsw2kNvEcqTKl/VqLat/MaB33pZy0y3rJZtnqwR2qOOvbwKZYKiEO1O6VqNEBxKvJJelCq0dTXWT5pbO2gDXC6h6QDXCaHo6pOHGPUy+YBaGQRGuSusMEASYiWunYN0vCAI8QaXnWMXNMdFP3jHAJH0eDsoiGnLPBlBp4TNm6rYI74nMzgz3B9IikW4WVK+dc8KZJZWYjAuORU3jc1c/NPskD2ASinf8v3xnfXeukU0sJ5N6m5E8VLjObPEO+mN2t/FZTMZLiFqPWc/ALSqnMnnhwrNi2rbfg/rd/IpL8Le3pSBne8+seeFVBoGqzHM9yXw==' \>> ~/.ssh/known_hosts
          # Set Checkout Key
          (umask 077; touch ~/.ssh/id_rsa)
          chmod 0600 ~/.ssh/id_rsa
          (cat \<<EOF > ~/.ssh/id_rsa
          $CHECKOUT_KEY
          EOF
          )
          # Set authentication method
          if [ "<< parameters.auth >>" == "SSH" ]
          then
            git config --global url."ssh://git@github.com".insteadOf "https://github.com" || true
            git config --global gc.auto 0 || true
          fi
          if [ << parameters.auth >> == "HTTPS" ]
          then
            git config --global url."https://github.com/".insteadOf "git://github.com/" || true
            git config --global gc.auto 0 || true
          fi
        name: Git-Tools Checkout Config
        shell: /bin/sh -e
    - when:
        condition: << parameters.cache_enabled >>
        steps:
        - restore_cache:
            keys:
            - gitTools-v1-{{ .Branch }}-{{ .Revision }}
            name: Checking For Source Cache
        - run:
            command: |
              # This step will check to see if ".git" directory has been restored, and if not the source will be checked out from the remote.
              if [ ! -d /home/circleci/project/.git ]
              then
                echo "No git repo present. Performing Clone."
                # Checkout code
                if [ -e /home/circleci/project/.git ]
                then
                  cd /home/circleci/project
                  git remote set-url origin "$CIRCLE_REPOSITORY_URL" || true
                else
                  mkdir -p /home/circleci/project
                  cd /home/circleci/project
                  git clone "$CIRCLE_REPOSITORY_URL" .
                fi
                if [ -n "$CIRCLE_TAG" ]
                then
                  git fetch --force origin "refs/tags/${CIRCLE_TAG}"
                else
                  git fetch --force origin "master:remotes/origin/master"
                fi
              else
                echo "Cache located"
              fi
            name: Fetching Source Location
        - save_cache:
            key: source-v1-{{ .Branch }}-{{ .Revision }}
            name: Saving Source Cache
            paths:
            - .git
    - unless:
        condition: << parameters.cache_enabled >>
        steps:
        - run:
            command: |
              # Checkout code
              if [ -e /home/circleci/project/.git ]
              then
                cd /home/circleci/project
                git remote set-url origin "$CIRCLE_REPOSITORY_URL" || true
              else
                mkdir -p /home/circleci/project
                cd /home/circleci/project
                git clone "$CIRCLE_REPOSITORY_URL" .
              fi

              if [ -n "$CIRCLE_TAG" ]
              then
                git fetch --force origin "refs/tags/${CIRCLE_TAG}"
              else
                git fetch --force origin "master:remotes/origin/master"
              fi
            name: Checking out Code
  committag:
    description: Tag the current commit with automatic semver incrementing. You will
      need a user key to push a tag back up to your VCS provider
    parameters:
      custom_tag:
        default: customtag
        description: 'Input a simple custom tag to push for this commit. Example:
          ''myTag-${CIRCLE_SHA1}'''
        type: string
      increment_major:
        default: false
        description: If increment_tag is enabled and this is true, the major version
          will be incremented.
        type: boolean
      increment_minor:
        default: false
        description: If increment_tag is enabled and this is true, the minor version
          will be incremented.
        type: boolean
      increment_patch:
        default: false
        description: If increment_tag is enabled and this is true, the patch version
          will be incremented.
        type: boolean
      increment_tag:
        default: false
        description: 'WILL OVERRIDE CUSTOM_TAG: This option will fetch the latest
          tag in the repo and attempt to automatically copy it and increment the semver
          leaving and prefix or suffix untouched. By default if set to true, a patch
          level increment will be made.'
        type: boolean
      tag_pattern:
        default: '*'
        description: 'By default the latest tag will be used. Use this option to match
          specifc tag matterns, ex: ''alpha-*'''
        type: string
    steps:
    - checkout
    - run:
        command: |
          git fetch --tags
          if [ <<parameters.increment_tag>> = true ]; then # If the increment_tag parameter is enabled...
            echo " [Increment tag selected] "
            GITLATESTTAG=$(git tag --list "<<parameters.tag_pattern>>" | sort -V | tail -1)
            printf " Latest matching tag: $(git tag --list "<<parameters.tag_pattern>>" | tail -1)"
            if [[ $GITLATESTTAG =~ ^(.*)(([0-9]+)\.([0-9]+)\.([0-9]+))(-.*)? ]]; then # If the tag has a valid SEMVER then proceed with upgrade
              echo "    Prefix: ${BASH_REMATCH[1]}"
              SEMPREFIX=${BASH_REMATCH[1]}
              echo "    Major: ${BASH_REMATCH[3]}"
              SEMVERMAJOR=${BASH_REMATCH[3]}
              echo "    Minor: ${BASH_REMATCH[4]}"
              SEMVERMINOR=${BASH_REMATCH[4]}
              echo "    Patch: ${BASH_REMATCH[5]}"
              SEMVERPATCH=${BASH_REMATCH[5]}
              echo "    Suffix: ${BASH_REMATCH[6]} "
              SEMVERSUFFIX=${BASH_REMATCH[6]}
              if [ <<parameters.increment_patch>> = true ]; then
                SEMVERPATCH=$(expr ${SEMVERPATCH} + 1)
                echo "Incrementing patch ${SEMVERPATCH}"
              fi
              if [ <<parameters.increment_minor>> = true ]; then
                SEMVERMINOR=$(expr ${SEMVERMINOR} + 1)
                echo "Incrementing minor ${SEMVERMINOR}"
              fi
              if [ <<parameters.increment_major>> = true ]; then
                SEMVERMAJOR=$(expr ${SEMVERMAJOR} + 1)
                echo "Incrementing major ${SEMVERMAJOR}"
              fi
              # Once the tag has been destructured and manipulated, put back together here
              GITNEWTAG="${SEMPREFIX}${SEMVERMAJOR}.${SEMVERMINOR}.${SEMVERPATCH}${SEMVERSUFFIX}"

            else # If no SEMVER found, but increment is enabled, fail.
              echo "Custom tag selected. Unable to find semver"
              exit 1
            fi
          else # If increment tag is not selected, a custom tag must be used.
            printf "Creating custom new tag"
            GITNEWTAG=<<parameters.custom_tag>>
            printf "Custom tag: ${GITNEWTAG}"
          fi
          # Complete tag creation. Newly created tag will now exist in $GITNEWTAG
          printf " Newly created tag: ${GITNEWTAG} "
          printf "Pushing '${GITNEWTAG}' to origin for commit ${CIRCLE_SHA1} "
          git tag ${GITNEWTAG} ${CIRCLE_SHA1}
          git push origin ${GITNEWTAG}
        name: Create and publish tagged commit
  git-tools-setup:
    description: 'Optional: Used by other steps. Configure settings for multi-VCS
      support.'
    steps:
    - run:
        command: |
          # Setup any needed ENV VARS for all other commands here.
          #
          # Set VCS_TYPE
          if [ ! -z $VCS_TYPE ] # Skip if already set.
            then
              echo "VCS already set:\ ${VCS_TYPE}"
              exit 0
          fi
          echo "Setting VCS_TYPE"
          VCS_TYPE=$(echo $CIRCLE_REPOSITORY_URL | grep -Po '(?<=@)[a-z]*(?=.com)')
          echo "VCS_TYPE is set to " $VCS_TYPE
          echo "export VCS_TYPE=${VCS_TYPE}" >> $BASH_ENV
          # Save commit message to GIT_COMMIT_MESSAGE
          # GIT_COMMIT_MESSAGE=$(git log -1 --pretty=%B)
          # echo "Git commit message: " $GIT_COMMIT_MESSAGE
          # echo 'export GIT_COMMIT_MESSAGE="${GIT_COMMIT_MESSAGE}"' >> $BASH_ENV
          echo "Setup complete"
        name: Git-Tools Setup
  prcomment:
    description: If the current commit is a part of a pull request, the commit message
      will be added to the PR as a comment. Only available for GitHub
    parameters:
      comment:
        default: ${VCS_COMMIT_MESSAGE}
        description: The comment to be submit to the PR request upon commit. By default,
          this will be the commit message
        type: string
      logpath:
        default: ${GITTOOLS_LOGPATH}
        description: path to logfile. Log file contents will be included in contents.
          Only the last 6 lines will be included
        type: string
      token:
        default: ${VCS_TOKEN}
        description: GitHub API token for accessing issue comments endpoint. This
          should be set to $VCS_TOKEN
        type: string
    steps:
    - git-tools-setup
    - run:
        command: |
          echo $VCS_TYPE
          if [ -z $CIRCLE_PULL_REQUEST ]
          then
            # The current commit is not a PR
            echo "The current build is not a Pull Request. If you intend to open an pull request after this commit, all following commits will be commented"
          else
            # Comment on pull request
            #
            if [ $VCS_TYPE == "github" ]
            then
              # GitHub PR Comment Module
              echo "GitHub PR Comment Module"
              # Fetch PR Number
              GITHUB_PR_NUM=$(echo $CIRCLE_PULL_REQUEST | rev | awk -F[/] '{print $1}')
              # Fetch log
              if [ ! -z $GITTOOLS_LOGPATH ]
              then
                PRCOMMENT_LOG="Log:\n$(cat $GITTOOLS_LOGPATH)"
              fi
              # Curl Request to post comment to PR
              ## Currently this seems to only update the top most comment.
              curl -s -H "Authorization: token ${VCS_TOKEN}" -X POST \
              -d "{\"body\": \"${GIT_COMMIT_MESSAGE} ${PRCOMMENT_LOG}\"}" \
              "https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/issues/${GITHUB_PR_NUM}/comments"
            elif [ $VCS_TYPE == "bitbucket" ]
            then
              # BitBucket PR Comment Module
              echo "The BitBucket PRComment module is not yet complete. Please consider contributing a PR."
            else
              echo "The VCS type is not yet supported."
            fi
          fi
        name: Commenting Pull Request
description: |
  Collection of useful Git-related tools for all VCS providers
executors:
  default:
    description: Basic container for running CircleCI commands.
    docker:
    - image: circleci/node
version: 2.1
